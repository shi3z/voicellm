<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width" />
  <title>Next-gen Kaldi WebAssembly with sherpa-onnx for VAD + ASR</title>
  <style>
    h1,div {
      text-align: center;
    }
    textarea {
      width:100%;
    }
    .loading {
      display: none !important;
    }
  </style>
</head>

<body style="font-family: 'Source Sans Pro', sans-serif; background-color: #f9fafb; color: #333; display: flex; flex-direction: column; align-items: center; height: 100vh; margin: 0;">
  <h1>Local LLMéŸ³å£°å¿œç­”ã‚·ã‚¹ãƒ†ãƒ </h1>

  <div style="width: 100%; max-width: 900px; background: #fff; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); flex: 1;">
    <div id="status">Loading...</div>

    <div id="singleAudioContent" class="tab-content loading">
      <div style="display: flex; gap: 1.5rem;">
        <div style="flex: 1; display: flex; flex-direction: column; gap: 1rem;">
          <!-- éŸ³å£°èªè­˜ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
          <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
            <div style="flex: 1; display: flex; flex-direction: row; align-items: center; gap: 1rem;">
              <button id="startBtn" disabled>Start</button>
              <button id="stopBtn" disabled>Stop</button>
              <button id="clearBtn">Clear</button>
            </div>

           <button id="clearConversationBtn" style="background: #dc3545; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">ä¼šè©±å±¥æ­´ã‚¯ãƒªã‚¢</button>
          </div>
          
          <!-- ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ› -->
          <div style="display: flex; gap: 0.5rem; align-items: stretch;">
            <input type="text" id="textInput" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›ã—ã¦Enterã‚­ãƒ¼ã¾ãŸã¯é€ä¿¡ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„..." 
              style="flex: 1; padding: 0.75rem; border: 1px solid #ced4da; border-radius: 4px; font-size: 1rem;">
            <button id="sendBtn" style="padding: 0.75rem 1rem; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">ğŸ“¤ é€ä¿¡</button>
          </div>
        </div>
      </div>
      
      <!-- è¨­å®šãƒ‘ãƒãƒ« (æŠ˜ã‚ŠãŸãŸã¿å¼) -->
      <div style="margin: 1rem 0; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
        <div id="settingsHeader" style="padding: 1rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center; user-select: none;" onclick="toggleSettings()">
          <h3 style="margin: 0; font-size: 1.1rem; color: #495057;">âš™ï¸ LMStudioè¨­å®š</h3>
          <span id="settingsToggle" style="font-size: 1.2rem; color: #6c757d;">â–¶</span>
        </div>
        
        <div id="settingsContent" style="padding: 0 1rem 1rem 1rem; display: none;">
          <div style="display: grid; gap: 1rem;">
            <!-- ãƒ¢ãƒ‡ãƒ«é¸æŠ -->
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <label for="modelSelect" style="font-weight: bold; color: #495057; min-width: 80px;">ãƒ¢ãƒ‡ãƒ«:</label>
              <select id="modelSelect" style="flex: 1; padding: 0.5rem; border: 1px solid #ced4da; border-radius: 4px; background: white;">
                <option value="">ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...</option>
              </select>
              <button id="refreshModels" style="padding: 0.5rem 0.75rem; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">ğŸ”„</button>
            </div>
            
            <!-- æœ€å¤§æ¨å¥¨ãƒˆãƒ¼ã‚¯ãƒ³æ•°ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ -->
            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
              <div style="display: flex; align-items: center; justify-content: space-between;">
                <label for="maxTokensSlider" style="font-weight: bold; color: #495057;">æœ€å¤§æ¨å¥¨ãƒˆãƒ¼ã‚¯ãƒ³æ•°:</label>
                <span id="maxTokensValue" style="font-weight: bold; color: #007bff; min-width: 80px; text-align: right;">1000</span>
              </div>
              <input id="maxTokensSlider" type="range" min="100" max="200000" step="100" value="1000" 
                style="width: 100%; height: 6px; border-radius: 3px; background: #ddd; outline: none; -webkit-appearance: none;" 
                oninput="updateTokensDisplay(this.value)">
              <div id="sliderLabels" style="display: flex; justify-content: space-between; font-size: 0.75rem; color: #6c757d;">
                <span>100</span>
                <span>50K</span>
                <span>100K</span>
                <span>200K</span>
              </div>
            </div>
            
            <!-- ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ -->
            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
              <label for="systemPrompt" style="font-weight: bold; color: #495057;">ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ:</label>
              <textarea id="systemPrompt" 
                style="padding: 0.5rem; border: 1px solid #ced4da; border-radius: 4px; resize: vertical; font-family: inherit; min-height: 80px;"
                placeholder="AIã®å‹•ä½œã‚’æŒ‡å®šã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„...">ã‚ãªãŸã¯è¦ªã—ã¿ã‚„ã™ã„æ—¥æœ¬èªã®ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚ç°¡æ½”ã§è‡ªç„¶ãªæ—¥æœ¬èªã§å¿œç­”ã—ã¦ãã ã•ã„ã€‚è‹±èªã¯ä¸€åˆ‡ä½¿ã‚ãªã„ã§ãã ã•ã„</textarea>
            </div>
            
            <!-- ãƒ„ãƒ¼ãƒ«è¨­å®š -->
            <div style="margin: 0.5rem 0; display: flex; align-items: center; gap: 0.5rem;">
              <input type="checkbox" id="enableTools" style="transform: scale(1.2);">
              <label for="enableTools" style="font-weight: bold; color: #495057;">ãƒ„ãƒ¼ãƒ«ä½¿ç”¨ã‚’æœ‰åŠ¹åŒ– (JavaScript/Pythonå®Ÿè¡Œ)</label>
            </div>
            
            <button id="saveConfig" style="padding: 0.75rem 1rem; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">ğŸ’¾ è¨­å®šä¿å­˜</button>
            
            <div id="configStatus" style="padding: 0.5rem; font-size: 0.875rem; color: #6c757d;"></div>
          </div>
        </div>
      </div>

      <div style="flex: 1; display: flex; flex-direction: column; gap: 1rem;">
          <textarea id="results" rows="10" style="display:none;" placeholder="Output will appear here..." readonly style="flex: 1; padding: 0.75rem; font-size: 1rem; border: 1px solid #ced4da; border-radius: 8px; resize: none; background-color: #f8f9fa;"></textarea>
          <div id="conversation" style="text-align: left; width: 100%; max-height: 800px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 8px; background-color: #fafafa;"></div>
          
          <div style="display: flex; gap: 1rem; margin-top: 1rem;">
            <div id="speechStatus" style="padding: 0.75rem; font-size: 0.9rem; color: #6c757d; background-color: #f8f9fa; border-radius: 8px; flex: 1;"></div>
          </div>
      </div>

      <section flex="1" overflow="auto" id="sound-clips" style="display:none">
      </section>
  </div>


  <script src="sherpa-onnx-asr.js"></script>
  <script src="sherpa-onnx-vad.js"></script>
  <script src="app-vad-asr.js"></script>
  <script src="sherpa-onnx-wasm-main-vad-asr.js"></script>
  
  <!-- ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ‘ãƒ¼ã‚µãƒ¼ -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  
  <script>
    // éŸ³å£°åˆæˆæ©Ÿèƒ½ã®å®Ÿè£…
    let speechSynth;
    let currentUtterance = null;
    let voices = [];
    
    // éŸ³å£°åˆæˆã®åˆæœŸåŒ–
    function initSpeechSynthesis() {
      if ('speechSynthesis' in window) {
        speechSynth = window.speechSynthesis;
        
        // éŸ³å£°ä¸€è¦§ã®å–å¾—ï¼ˆéåŒæœŸï¼‰
        function loadVoices() {
          voices = speechSynth.getVoices();
          console.log('Available voices:', voices);
          
          // æ—¥æœ¬èªéŸ³å£°ã‚’æ¢ã™
          const japaneseVoices = voices.filter(voice => 
            voice.lang.includes('ja') || voice.lang.includes('JP')
          );
          console.log('Japanese voices:', japaneseVoices);
        }
        
        // éŸ³å£°ä¸€è¦§ã®èª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…ã¤
        if (voices.length === 0) {
          speechSynth.addEventListener('voiceschanged', loadVoices);
        } else {
          loadVoices();
        }
        
        return true;
      } else {
        console.error('Speech synthesis not supported');
        return false;
      }
    }
    
    // è¨­å®šã®æŠ˜ã‚ŠãŸãŸã¿ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹é–¢æ•°ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«é…ç½®ï¼‰
    function toggleSettings() {
      const content = document.getElementById('settingsContent');
      const toggle = document.getElementById('settingsToggle');
      
      if (content.style.display === 'none') {
        content.style.display = 'block';
        toggle.textContent = 'â–¼';
        localStorage.setItem('voiceui_settings_collapsed', 'false');
      } else {
        content.style.display = 'none';
        toggle.textContent = 'â–¶';
        localStorage.setItem('voiceui_settings_collapsed', 'true');
      }
    }

    // ãƒˆãƒ¼ã‚¯ãƒ³æ•°è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«é…ç½®ï¼‰
    function updateTokensDisplay(value) {
      const display = document.getElementById('maxTokensValue');
      if (!display) return;
      
      const numValue = parseInt(value);
      
      if (numValue >= 1000) {
        display.textContent = (numValue / 1000).toFixed(0) + 'K';
      } else {
        display.textContent = numValue;
      }
    }

    // ãƒ–ãƒ©ã‚¦ã‚¶éŸ³å£°èªè­˜ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
    function startBrowserSpeechRecognition() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        alert('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯éŸ³å£°èªè­˜ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚');
        return;
      }

      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      const recognition = new SpeechRecognition();
      
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'ja-JP';

      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const results = document.getElementById('results');

      recognition.onstart = function() {
        console.log('ãƒ–ãƒ©ã‚¦ã‚¶éŸ³å£°èªè­˜é–‹å§‹');
        startBtn.disabled = true;
        stopBtn.disabled = false;
        startBtn.textContent = 'ğŸ¤ èªè­˜ä¸­...';
      };

      recognition.onresult = function(event) {
        let finalTranscript = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
          if (event.results[i].isFinal) {
            finalTranscript += event.results[i][0].transcript;
          }
        }
        
        if (finalTranscript && results) {
          results.value = finalTranscript;
          console.log('éŸ³å£°èªè­˜çµæœ:', finalTranscript);
        }
      };

      recognition.onerror = function(event) {
        console.error('éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼:', event.error);
        startBtn.disabled = false;
        stopBtn.disabled = true;
        startBtn.textContent = 'ğŸ¤ éŸ³å£°èªè­˜é–‹å§‹';
      };

      recognition.onend = function() {
        console.log('éŸ³å£°èªè­˜çµ‚äº†');
        startBtn.disabled = false;
        stopBtn.disabled = true;
        startBtn.textContent = 'ğŸ¤ éŸ³å£°èªè­˜é–‹å§‹';
      };

      // åœæ­¢ãƒœã‚¿ãƒ³ã®è¨­å®š
      stopBtn.onclick = function() {
        recognition.stop();
      };

      recognition.start();
    }

    // éŸ³å£°å¿œç­”ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    document.addEventListener('DOMContentLoaded', function() {
      const speakBtn = document.getElementById('speakBtn');
      const speechStatus = document.getElementById('speechStatus');
      const results = document.getElementById('results');
      
      // éŸ³å£°åˆæˆã®åˆæœŸåŒ–
      const speechSupported = initSpeechSynthesis();
      
      if (!speechSupported) {
        speechStatus.textContent = 'ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯éŸ³å£°åˆæˆã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“';
        speakBtn.disabled = true;
        return;
      }
      
      // éŸ³å£°èªè­˜ã®åˆ¶å¾¡
      let isRecording = false;
      
      function pauseRecording() {
        const stopBtn = document.getElementById('stopBtn');
        if (!stopBtn.disabled) {
          console.log('Pausing recording for speech synthesis');
          stopBtn.click(); // éŸ³å£°èªè­˜ã‚’åœæ­¢
          isRecording = true; // å†é–‹ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
        }
      }
      
      function resumeRecording() {
        const startBtn = document.getElementById('startBtn');
        if (isRecording && !startBtn.disabled) {
          console.log('Resuming recording after speech synthesis');
          setTimeout(() => {
            startBtn.click(); // éŸ³å£°èªè­˜ã‚’å†é–‹
            isRecording = false;
          }, 500); // å°‘ã—é…å»¶ã‚’å…¥ã‚Œã‚‹
        }
      }

      // éŸ³å£°åˆæˆç”¨ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹é–¢æ•°
      function cleanTextForSpeech(text) {
        // ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’é™¤å»
        text = text.replace(/```[\s\S]*?```/g, '');
        
        // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’é™¤å»
        text = text.replace(/`[^`]*`/g, '');
        
        // ã‚³ãƒ¼ãƒ‰é–¢é€£ã®å˜èªã‚’é™¤å»
        text = text.replace(/JavaScript|Python|HTML|CSS|Node\.js|ã‚³ãƒ¼ãƒ‰|ãƒ—ãƒ­ã‚°ãƒ©ãƒ |ã‚¹ã‚¯ãƒªãƒ—ãƒˆ|å®Ÿè¡Œçµæœ|Output:|Error:/gi, '');
        
        // é€£ç¶šã™ã‚‹ç©ºç™½ã‚’å˜ä¸€ã‚¹ãƒšãƒ¼ã‚¹ã«
        text = text.replace(/\s+/g, ' ').trim();
        
        return text;
      }
      
      // è‹±èªéƒ¨åˆ†ã‚’æ¤œå‡ºã™ã‚‹é–¢æ•°
      function detectLanguageSegments(text) {
        // éŸ³å£°åˆæˆç”¨ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        text = cleanTextForSpeech(text);
        console.log('Cleaned text for speech:', text);
        
        // ç©ºã«ãªã£ãŸå ´åˆã¯å‡¦ç†ã—ãªã„
        if (!text || text.trim().length === 0) {
          return [];
        }
        
        // è‹±èªã®ãƒ•ãƒ¬ãƒ¼ã‚ºã‚’æ¤œå‡ºã™ã‚‹æ­£è¦è¡¨ç¾ï¼ˆè‹±å˜èª+ã‚¹ãƒšãƒ¼ã‚¹ã‚’å«ã‚€ã€ã‚¯ã‚©ãƒ¼ãƒˆã§å›²ã¾ã‚ŒãŸæ–‡å­—åˆ—ã‚‚å«ã‚€ï¼‰
        const englishRegex = /("[^"]*")|([a-zA-Z]+(?:[''][a-zA-Z]+)*(?:\s+[a-zA-Z]+(?:[''][a-zA-Z]+)*)*)/g;
        const segments = [];
        let lastIndex = 0;
        let match;
        
        // è‹±èªéƒ¨åˆ†ã‚’æ¤œå‡º
        while ((match = englishRegex.exec(text)) !== null) {
          // è‹±èªã®å‰ã®æ—¥æœ¬èªéƒ¨åˆ†
          if (match.index > lastIndex) {
            const japaneseText = text.substring(lastIndex, match.index).trim();
            if (japaneseText) {
              segments.push({ text: japaneseText, lang: 'ja-JP', type: 'japanese' });
            }
          }
          
          // ãƒãƒƒãƒã—ãŸå†…å®¹ã‚’å–å¾—ï¼ˆã‚¯ã‚©ãƒ¼ãƒˆæ–‡å­—åˆ—ã¾ãŸã¯ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆéƒ¨åˆ†ï¼‰
          const matchedText = match[1] || match[2]; // match[1]ãŒã‚¯ã‚©ãƒ¼ãƒˆæ–‡å­—åˆ—ã€match[2]ãŒé€šå¸¸ã®è‹±èª
          if (matchedText) {
            segments.push({ text: matchedText, lang: 'en-US', type: 'english' });
          }
          lastIndex = match.index + match[0].length;
        }
        
        // æœ€å¾Œã®æ—¥æœ¬èªéƒ¨åˆ†
        if (lastIndex < text.length) {
          const remainingText = text.substring(lastIndex).trim();
          if (remainingText) {
            segments.push({ text: remainingText, lang: 'ja-JP', type: 'japanese' });
          }
        }
        
        // è‹±èªãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯å…¨ä½“ã‚’æ—¥æœ¬èªã¨ã—ã¦æ‰±ã†
        if (segments.length === 0) {
          segments.push({ text: text.trim(), lang: 'ja-JP', type: 'japanese' });
        }
        
        return segments;
      }
      
      // è¤‡æ•°ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’é †æ¬¡å†ç”Ÿã™ã‚‹é–¢æ•°
      function speakSegments(segments, currentIndex = 0) {
        if (currentIndex >= segments.length) {
          console.log('All segments completed');
          speechStatus.textContent = 'AIå¿œç­”å®Œäº†';
          // éŸ³å£°åˆæˆçµ‚äº†å¾Œã«éŸ³å£°èªè­˜ã‚’å†é–‹
          resumeRecording();
          return;
        }
        
        const segment = segments[currentIndex];
        console.log(`Speaking segment ${currentIndex + 1}/${segments.length}: "${segment.text}" (${segment.lang})`);
        
        // æ—¢å­˜ã®éŸ³å£°ã‚’åœæ­¢
        if (speechSynth.speaking || speechSynth.pending) {
          speechSynth.cancel();
        }
        
        const utterance = new SpeechSynthesisUtterance(segment.text);
        utterance.lang = segment.lang;
        
        // è¨€èªã«å¿œã˜ã¦éŸ³å£°ã‚’é¸æŠ
        if (segment.type === 'english') {
          const englishVoice = voices.find(voice => 
            voice.lang.includes('en') || voice.lang.includes('US')
          );
          if (englishVoice) {
            utterance.voice = englishVoice;
            console.log('Using English voice:', englishVoice.name);
          }
        } else {
          const japaneseVoice = voices.find(voice => 
            voice.lang.includes('ja') || voice.lang.includes('JP')
          );
          if (japaneseVoice) {
            utterance.voice = japaneseVoice;
            console.log('Using Japanese voice:', japaneseVoice.name);
          }
        }
        
        utterance.rate = 0.9;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        utterance.onend = function() {
          // æ¬¡ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’å†ç”Ÿ
          setTimeout(() => speakSegments(segments, currentIndex + 1), 100);
        };
        
        utterance.onerror = function(event) {
          console.error('Speech error in segment:', event);
          // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚æ¬¡ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã«é€²ã‚€
          setTimeout(() => speakSegments(segments, currentIndex + 1), 100);
        };
        
        speechSynth.speak(utterance);
      }

      // éŸ³å£°å¿œç­”æ©Ÿèƒ½
      function speakText(text, isApiResponse = false) {
        console.log('speakText called with:', text, 'isApiResponse:', isApiResponse);
        
        if (!text || text.trim() === '') {
          speechStatus.textContent = 'å¿œç­”ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆãŒã‚ã‚Šã¾ã›ã‚“';
          return;
        }
        
        let textToSpeak = '';
        
        if (isApiResponse) {
          // APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å ´åˆã¯ãã®ã¾ã¾ä½¿ç”¨
          textToSpeak = text.trim();
        } else {
          // éŸ³å£°èªè­˜çµæœã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆéƒ¨åˆ†ã®ã¿ã‚’æŠ½å‡º
          const lines = text.split('\n');
          
          for (const line of lines) {
            if (line.includes('Result:')) {
              const resultPart = line.split('Result:')[1];
              if (resultPart) {
                textToSpeak += resultPart.trim() + ' ';
              }
            }
          }
        }
        
        if (!textToSpeak.trim()) {
          speechStatus.textContent = isApiResponse ? 'AIãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒç©ºã§ã™' : 'éŸ³å£°èªè­˜çµæœãŒã‚ã‚Šã¾ã›ã‚“';
          return;
        }
        
        console.log('Text to speak:', textToSpeak);
        
        // éŸ³å£°åˆæˆé–‹å§‹å‰ã«éŸ³å£°èªè­˜ã‚’åœæ­¢
        pauseRecording();
        
        // æ—¢å­˜ã®éŸ³å£°ã‚’åœæ­¢
        if (speechSynth.speaking || speechSynth.pending) {
          console.log('Cancelling previous speech');
          speechSynth.cancel();
        }
        
        // è¨€èªã‚»ã‚°ãƒ¡ãƒ³ãƒˆã«åˆ†å‰²
        const segments = detectLanguageSegments(textToSpeak.trim());
        console.log('Language segments:', segments);
        
        speechStatus.textContent = isApiResponse ? 'AIå¿œç­”ä¸­ï¼ˆéŒ²éŸ³åœæ­¢ï¼‰...' : 'éŸ³å£°å¿œç­”ä¸­ï¼ˆéŒ²éŸ³åœæ­¢ï¼‰...';
        
        // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’é †æ¬¡å†ç”Ÿ
        speakSegments(segments);
      }
      
      // éŸ³å£°èªè­˜çµæœãŒæ›´æ–°ã•ã‚ŒãŸæ™‚ã®å‡¦ç†
      let lastText = '';
      
      // ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã®å¤‰æ›´ã‚’ç›£è¦–
      const textAreaObserver = new MutationObserver(function(mutations) {
        const currentText = results.value;
        if (currentText !== lastText && currentText.trim() !== '') {
          console.log('Text area updated:', currentText);
          lastText = currentText;
          speechStatus.textContent = 'éŸ³å£°å¿œç­”æº–å‚™å®Œäº†';
        }
      });
      
      // ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã®inputã‚¤ãƒ™ãƒ³ãƒˆã‚‚ç›£è¦–
      results.addEventListener('input', function() {
        const currentText = results.value;
        if (currentText !== lastText && currentText.trim() !== '') {
          console.log('Input event:', currentText);
          lastText = currentText;
          speechStatus.textContent = 'éŸ³å£°å¿œç­”æº–å‚™å®Œäº†';
        }
      });
      
      // ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’HTMLã«å¤‰æ›ã™ã‚‹é–¢æ•°
      function parseMarkdown(text) {
        if (typeof marked !== 'undefined') {
          // markedãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ
          return marked.parse(text);
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç°¡å˜ãªãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å‡¦ç†
          return text
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/`(.*?)`/g, '<code>$1</code>')
            .replace(/\n/g, '<br/>');
        }
      }

      // Python API ã‚µãƒ¼ãƒãƒ¼å‘¼ã³å‡ºã—æ©Ÿèƒ½
      async function callPythonAPI(userInput) {
        var conversation = document.getElementById('conversation');
        try {
          speechStatus.textContent = 'AIã«å•ã„åˆã‚ã›ä¸­...';
          conversation.innerHTML += "<div style='margin: 10px 0; padding: 10px; background: #e3f2fd; border-radius: 5px; text-align: left;'><B>USER:</B> <span style='color: #1976d2;'>" + userInput + "</span></div>";
          
          const enableTools = document.getElementById('enableTools').checked;
          
          const systemPrompt = document.getElementById('systemPrompt').value;
          
          const response = await fetch('/api/chat', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              message: userInput,
              enable_tools: enableTools,
              system_prompt: systemPrompt
            })
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          
          if (data.status === 'success') {
            const aiResponse = data.response;
            console.log('Python API response:', aiResponse);
            
            // ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’HTMLã«å¤‰æ›
            const htmlResponse = parseMarkdown(aiResponse);
            
            // APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¡¨ç¤º
            conversation.innerHTML += "<div style='margin: 10px 0; padding: 10px; background: #f1f8e9; border-radius: 5px; text-align: left;'><B>AI:</B> <div style='color: #388e3c; margin-top: 5px; text-align: left;'>" + htmlResponse + "</div></div>";
            
            // éŸ³å£°åˆæˆã§ã¯å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½¿ç”¨ï¼ˆHTMLã‚¿ã‚°ãªã—ï¼‰
            speakText(aiResponse, true);
            
            // ä¼šè©±å±¥æ­´ã®æœ€ä¸‹éƒ¨ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
            conversation.scrollTop = conversation.scrollHeight;
          } else {
            throw new Error(data.error || 'Unknown error');
          }
          
        } catch (error) {
          console.error('Python API error:', error);
          speechStatus.textContent = 'APIæ¥ç¶šã‚¨ãƒ©ãƒ¼: ' + error.message;
          
          // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ãã®ã¾ã¾èª­ã¿ä¸Šã’
          speakText(`${userInput}ã«ã¤ã„ã¦ã€ç†è§£ã—ã¾ã—ãŸã€‚`, true);
        }
      }

      // PropertyObserverï¼ˆãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã®å€¤ã®å¤‰æ›´ã‚’æ¤œçŸ¥ï¼‰
      let lastValue = '';
      setInterval(function() {
        if (results.value !== lastValue) {
          lastValue = results.value;
          console.log("éŸ³å£°èªè­˜çµæœ:", lastValue)
          
          // éŸ³å£°èªè­˜çµæœã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡º
          const lines = lastValue.split('\n');
          let recognizedText = '';
          for (const line of lines) {
            if (line.includes('Result:')) {
              const resultPart = line.split('Result:')[1];
              if (resultPart) {
                recognizedText += resultPart.trim() + ' ';
              }
            }
          }
          
          if (recognizedText.trim()) {
            // Python APIã‚µãƒ¼ãƒãƒ¼ã‚’å‘¼ã³å‡ºã—
            callPythonAPI(recognizedText.trim());
          }
          
          results.value="";
          const clearBtn = document.getElementById('clearBtn');
          clearBtn.click();

          if (lastValue.trim() !== '') {
            speechStatus.textContent = 'éŸ³å£°å¿œç­”æº–å‚™å®Œäº†';
          }
        }
      }, 500);
      
      // ãƒ¢ãƒ‡ãƒ«ä¸€è¦§ã‚’å–å¾—ã™ã‚‹é–¢æ•°
      async function loadModels() {
        const modelSelect = document.getElementById('modelSelect');
        const configStatus = document.getElementById('configStatus');
        
        try {
          configStatus.textContent = 'ãƒ¢ãƒ‡ãƒ«ä¸€è¦§ã‚’å–å¾—ä¸­...';
          
          const response = await fetch('/api/models');
          const data = await response.json();
          
          console.log('Received models data:', data);
          console.log('First model details:', data.models[0]);
          
          if (data.status === 'success') {
            modelSelect.innerHTML = '';
            
            if (data.models.length === 0) {
              modelSelect.innerHTML = '<option value="">ãƒ¢ãƒ‡ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</option>';
              configStatus.textContent = 'LMStudioã§ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„';
            } else {
              data.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                const contextLength = model.max_context_length || 4096;
                option.textContent = `${model.id} (context: ${contextLength.toLocaleString()})`;
                option.setAttribute('data-max-context', contextLength);
                modelSelect.appendChild(option);
                console.log(`Added model: ${model.id}, context: ${contextLength}`);
              });
              configStatus.textContent = `${data.models.length}å€‹ã®ãƒ¢ãƒ‡ãƒ«ãŒåˆ©ç”¨å¯èƒ½`;
            }
          } else {
            throw new Error(data.error);
          }
        } catch (error) {
          console.error('Failed to load models:', error);
          modelSelect.innerHTML = '<option value="">ã‚¨ãƒ©ãƒ¼: ãƒ¢ãƒ‡ãƒ«å–å¾—å¤±æ•—</option>';
          configStatus.textContent = 'LMStudioã¨ã®æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„';
        }
      }
      
      // ç¾åœ¨ã®è¨­å®šã‚’å–å¾—ã™ã‚‹é–¢æ•°
      async function loadConfig() {
        try {
          const response = await fetch('/api/config');
          const data = await response.json();
          
          if (data.status === 'success') {
            const modelSelect = document.getElementById('modelSelect');
            const maxTokensSlider = document.getElementById('maxTokensSlider');
            
            if (modelSelect) {
              modelSelect.value = data.model_id;
            }
            if (maxTokensSlider) {
              maxTokensSlider.value = data.max_tokens;
              updateTokensDisplay(data.max_tokens);
            }
          }
        } catch (error) {
          console.error('Failed to load config:', error);
        }
        
        // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰è¨­å®šã‚’èª­ã¿è¾¼ã¿
        loadLocalSettings();
      }
      
      // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰è¨­å®šã‚’èª­ã¿è¾¼ã‚€é–¢æ•°
      function loadLocalSettings() {
        try {
          // è¨­å®šãƒ‘ãƒãƒ«ã®è¡¨ç¤ºçŠ¶æ…‹ã‚’å¾©å…ƒï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æŠ˜ã‚ŠãŸãŸã¿ï¼‰
          const collapsed = localStorage.getItem('voiceui_settings_collapsed');
          if (collapsed === 'false') {
            document.getElementById('settingsContent').style.display = 'block';
            document.getElementById('settingsToggle').textContent = 'â–¼';
          } else {
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æŠ˜ã‚ŠãŸãŸã¿
            document.getElementById('settingsContent').style.display = 'none';
            document.getElementById('settingsToggle').textContent = 'â–¶';
          }
          
          const enableTools = localStorage.getItem('voiceui_enable_tools');
          if (enableTools !== null) {
            document.getElementById('enableTools').checked = enableTools === 'true';
          }
          
          const modelId = localStorage.getItem('voiceui_model_id');
          if (modelId && document.getElementById('modelSelect')) {
            // ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒèª­ã¿è¾¼ã¾ã‚ŒãŸå¾Œã«è¨­å®š
            setTimeout(() => {
              const selectElement = document.getElementById('modelSelect');
              if (selectElement && Array.from(selectElement.options).some(option => option.value === modelId)) {
                selectElement.value = modelId;
                // ãƒ¢ãƒ‡ãƒ«å¤‰æ›´æ™‚ã«max_tokensã‚’è‡ªå‹•æ›´æ–°
                updateMaxTokensFromModel();
              }
            }, 500);
          }
          
          const maxTokens = localStorage.getItem('voiceui_max_tokens');
          if (maxTokens) {
            const slider = document.getElementById('maxTokensSlider');
            slider.value = maxTokens;
            updateTokensDisplay(maxTokens);
          }
          
          const systemPrompt = localStorage.getItem('voiceui_system_prompt');
          if (systemPrompt) {
            document.getElementById('systemPrompt').value = systemPrompt;
          }
          
          console.log('Loaded settings from localStorage');
        } catch (error) {
          console.error('Failed to load settings from localStorage:', error);
        }
      }
      
      // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«è¨­å®šã‚’ä¿å­˜ã™ã‚‹é–¢æ•°
      function saveLocalSettings() {
        try {
          const enableTools = document.getElementById('enableTools').checked;
          const modelId = document.getElementById('modelSelect').value;
          const maxTokens = document.getElementById('maxTokensSlider').value;
          const systemPrompt = document.getElementById('systemPrompt').value;
          
          localStorage.setItem('voiceui_enable_tools', enableTools);
          localStorage.setItem('voiceui_model_id', modelId);
          localStorage.setItem('voiceui_max_tokens', maxTokens);
          localStorage.setItem('voiceui_system_prompt', systemPrompt);
          
          console.log('Saved settings to localStorage');
        } catch (error) {
          console.error('Failed to save settings to localStorage:', error);
        }
      }
      
      // è¨­å®šã‚’ä¿å­˜ã™ã‚‹é–¢æ•°
      async function saveConfig() {
        const modelSelect = document.getElementById('modelSelect');
        const maxTokensSlider = document.getElementById('maxTokensSlider');
        const enableTools = document.getElementById('enableTools');
        const configStatus = document.getElementById('configStatus');
        
        try {
          configStatus.textContent = 'è¨­å®šã‚’ä¿å­˜ä¸­...';
          
          const response = await fetch('/api/config', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              model_id: modelSelect.value,
              max_tokens: parseInt(maxTokensSlider.value)
            })
          });
          
          const data = await response.json();
          
          if (data.status === 'success') {
            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ã‚‚ä¿å­˜
            saveLocalSettings();
            
            const toolsStatus = enableTools.checked ? 'ãƒ„ãƒ¼ãƒ«æœ‰åŠ¹' : 'ãƒ„ãƒ¼ãƒ«ç„¡åŠ¹';
            configStatus.textContent = `è¨­å®šä¿å­˜å®Œäº† - ãƒ¢ãƒ‡ãƒ«: ${data.model_id}, æ¨å¥¨ãƒˆãƒ¼ã‚¯ãƒ³æ•°: ${data.max_tokens}, ${toolsStatus}`;
            configStatus.style.color = '#28a745';
          } else {
            throw new Error(data.error);
          }
        } catch (error) {
          console.error('Failed to save config:', error);
          configStatus.textContent = 'è¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ';
        }
      }
      
      // ä¼šè©±å±¥æ­´ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹é–¢æ•°
      async function clearConversation() {
        const configStatus = document.getElementById('configStatus');
        const conversation = document.getElementById('conversation');
        
        try {
          configStatus.textContent = 'ä¼šè©±å±¥æ­´ã‚’ã‚¯ãƒªã‚¢ä¸­...';
          
          const response = await fetch('/api/conversation', {
            method: 'DELETE'
          });
          
          const data = await response.json();
          
          if (data.status === 'success') {
            conversation.innerHTML = '';
            configStatus.textContent = 'ä¼šè©±å±¥æ­´ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ';
          } else {
            throw new Error(data.error);
          }
        } catch (error) {
          console.error('Failed to clear conversation:', error);
          configStatus.textContent = 'ä¼šè©±å±¥æ­´ã®ã‚¯ãƒªã‚¢ã«å¤±æ•—ã—ã¾ã—ãŸ';
        }
      }
      
      // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ãƒ©ãƒ™ãƒ«ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
      function updateSliderLabels(maxValue) {
        const labels = document.getElementById('sliderLabels');
        const quarter = Math.floor(maxValue / 4);
        const half = Math.floor(maxValue / 2);
        const threeQuarter = Math.floor(maxValue * 3 / 4);
        
        function formatValue(value) {
          if (value >= 1000) {
            return Math.floor(value / 1000) + 'K';
          }
          return value.toString();
        }
        
        labels.innerHTML = `
          <span>100</span>
          <span>${formatValue(quarter)}</span>
          <span>${formatValue(half)}</span>
          <span>${formatValue(threeQuarter)}</span>
          <span>${formatValue(maxValue)}</span>
        `;
      }
      
      // ãƒ¢ãƒ‡ãƒ«é¸æŠæ™‚ã«max_tokensã‚’è‡ªå‹•è¨­å®š
      function updateMaxTokensFromModel() {
        const modelSelect = document.getElementById('modelSelect');
        const maxTokensSlider = document.getElementById('maxTokensSlider');
        const configStatus = document.getElementById('configStatus');
        
        const selectedOption = modelSelect.options[modelSelect.selectedIndex];
        if (selectedOption && selectedOption.getAttribute('data-max-context')) {
          const maxContext = parseInt(selectedOption.getAttribute('data-max-context'));
          
          // æ¨å¥¨ãƒˆãƒ¼ã‚¯ãƒ³æ•°ã‚’max_context_lengthã®75%ã«è¨­å®šï¼ˆä½™è£•ã‚’æŒãŸã›ã‚‹ï¼‰
          const recommendedMaxTokens = Math.floor(maxContext * 0.75);
          
          // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®æœ€å¤§å€¤ã‚’ãƒ¢ãƒ‡ãƒ«ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆé•·ã«è¨­å®š
          const sliderMax = Math.min(maxContext, 500000); // æœ€å¤§500Kã¾ã§
          maxTokensSlider.max = sliderMax;
          maxTokensSlider.value = recommendedMaxTokens;
          updateTokensDisplay(recommendedMaxTokens);
          updateSliderLabels(sliderMax);
          
          configStatus.textContent = `ãƒ¢ãƒ‡ãƒ«ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆé•·: ${maxContext.toLocaleString()}, æ¨å¥¨ãƒˆãƒ¼ã‚¯ãƒ³æ•°: ${recommendedMaxTokens.toLocaleString()}`;
        } else {
          // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šï¼ˆãƒ¢ãƒ‡ãƒ«æƒ…å ±ãŒãªã„å ´åˆï¼‰
          maxTokensSlider.max = 32768;
          updateSliderLabels(32768);
        }
      }
      
      // ãƒ†ã‚­ã‚¹ãƒˆé€ä¿¡æ©Ÿèƒ½
      async function sendTextMessage() {
        const textInput = document.getElementById('textInput');
        const message = textInput.value.trim();
        
        if (!message) {
          return;
        }
        
        // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã‚¯ãƒªã‚¢
        textInput.value = '';
        
        // éŸ³å£°å¿œç­”ã‚’å‘¼ã³å‡ºã—
        await callPythonAPI(message);
      }
      
      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
      document.getElementById('refreshModels').addEventListener('click', loadModels);
      document.getElementById('saveConfig').addEventListener('click', saveConfig);
      document.getElementById('clearConversationBtn').addEventListener('click', clearConversation);
      document.getElementById('modelSelect').addEventListener('change', updateMaxTokensFromModel);
      
      // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
      document.getElementById('sendBtn').addEventListener('click', sendTextMessage);
      document.getElementById('textInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          sendTextMessage();
        }
      });
      
      // åˆæœŸçŠ¶æ…‹è¨­å®š
      speechStatus.textContent = 'éŸ³å£°åˆæˆã‚’åˆæœŸåŒ–ã—ã¦ã„ã¾ã™...';
      
      // åˆæœŸåŒ–å®Œäº†å¾Œã®å‡¦ç†
      setTimeout(async () => {
        // LoadingçŠ¶æ…‹ã‚’æ‰‹å‹•ã§è§£é™¤
        const statusElement = document.getElementById('status');
        if (statusElement) {
          statusElement.style.display = 'none';
        }
        document.querySelectorAll('.tab-content').forEach((tabContentElement) => {
          tabContentElement.classList.remove('loading');
        });
        
        // éŸ³å£°èªè­˜ãƒœã‚¿ãƒ³ã‚’æ‰‹å‹•ã§æœ‰åŠ¹åŒ–
        const startBtn = document.getElementById('startBtn');
        if (startBtn) {
          startBtn.disabled = false;
          
          // app-vad-asr.jsã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          // å°‘ã—é…å»¶ã—ã¦ã‹ã‚‰ãƒã‚§ãƒƒã‚¯
          setTimeout(() => {
            if (startBtn.onclick === null) {
              console.log('WebAssemblyéŸ³å£°èªè­˜ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚ãƒ–ãƒ©ã‚¦ã‚¶éŸ³å£°èªè­˜ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚');
              startBtn.onclick = function() {
                startBrowserSpeechRecognition();
              };
            }
          }, 2000);
        }
        
        if (speechSynth && speechSynth.getVoices().length > 0) {
          speechStatus.textContent = 'éŸ³å£°èªè­˜ã‚’é–‹å§‹ã—ã¦ãã ã•ã„';
        } else {
          speechStatus.textContent = 'éŸ³å£°åˆæˆã®åˆæœŸåŒ–ä¸­...';
        }
        
        // ãƒ¢ãƒ‡ãƒ«ä¸€è¦§ã¨ç¾åœ¨ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿
        await loadModels();
        await loadConfig();
        
        // åˆæœŸãƒ¢ãƒ‡ãƒ«é¸æŠæ™‚ã«max_tokensã‚’è‡ªå‹•è¨­å®š
        updateMaxTokensFromModel();
      }, 1000);
    });
  </script>
</body>
