<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width" />
  <title>Next-gen Kaldi WebAssembly with sherpa-onnx for VAD + ASR</title>
  <style>
    h1,div {
      text-align: center;
    }
    textarea {
      width:100%;
    }
    .loading {
      display: none !important;
    }
  </style>
</head>

<body style="font-family: 'Source Sans Pro', sans-serif; background-color: #f9fafb; color: #333; display: flex; flex-direction: column; align-items: center; height: 100vh; margin: 0;">
  <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 900px; margin-bottom: 1rem;">
    <h1 id="main-title">VoiceLLM</h1>
    <button id="langToggle" style="padding: 0.5rem 1rem; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">🌐 EN</button>
  </div>

  <div style="width: 100%; max-width: 900px; background: #fff; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); flex: 1;">
    <div id="status">Loading...</div>

    <div id="singleAudioContent" class="tab-content loading">
      <div style="display: flex; gap: 1.5rem;">
        <div style="flex: 1; display: flex; flex-direction: column; gap: 1rem;">
          <!-- 音声認識コントロール -->
          <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
            <div style="flex: 1; display: flex; flex-direction: row; align-items: center; gap: 1rem;">
              <button id="startBtn" disabled>Start</button>
              <button id="stopBtn" disabled>Stop</button>
              <button id="clearBtn">Clear</button>
            </div>

           <button id="clearConversationBtn" style="background: #dc3545; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">会話履歴クリア</button>
          </div>
          
          <!-- テキスト入力 -->
          <div style="display: flex; gap: 0.5rem; align-items: stretch;">
            <input type="text" id="textInput" placeholder="メッセージを入力してEnterキーまたは送信ボタンを押してください..." 
              style="flex: 1; padding: 0.75rem; border: 1px solid #ced4da; border-radius: 4px; font-size: 1rem;">
            <button id="sendBtn" style="padding: 0.75rem 1rem; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">📤 送信</button>
          </div>
        </div>
      </div>
      
      <!-- 設定パネル (折りたたみ式) -->
      <div style="margin: 1rem 0; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
        <div id="settingsHeader" style="padding: 1rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center; user-select: none;" onclick="toggleSettings()">
          <h3 style="margin: 0; font-size: 1.1rem; color: #495057;">⚙️ LMStudio設定</h3>
          <span id="settingsToggle" style="font-size: 1.2rem; color: #6c757d;">▶</span>
        </div>
        
        <div id="settingsContent" style="padding: 0 1rem 1rem 1rem; display: none;">
          <div style="display: grid; gap: 1rem;">
            <!-- モデル選択 -->
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <label for="modelSelect" style="font-weight: bold; color: #495057; min-width: 80px;">モデル:</label>
              <select id="modelSelect" style="flex: 1; padding: 0.5rem; border: 1px solid #ced4da; border-radius: 4px; background: white;">
                <option value="">モデルを読み込み中...</option>
              </select>
              <button id="refreshModels" style="padding: 0.5rem 0.75rem; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">🔄</button>
            </div>
            
            <!-- 最大推奨トークン数スライダー -->
            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
              <div style="display: flex; align-items: center; justify-content: space-between;">
                <label for="maxTokensSlider" style="font-weight: bold; color: #495057;">最大推奨トークン数:</label>
                <span id="maxTokensValue" style="font-weight: bold; color: #007bff; min-width: 80px; text-align: right;">1000</span>
              </div>
              <input id="maxTokensSlider" type="range" min="100" max="200000" step="100" value="1000" 
                style="width: 100%; height: 6px; border-radius: 3px; background: #ddd; outline: none; -webkit-appearance: none;" 
                oninput="updateTokensDisplay(this.value)">
              <div id="sliderLabels" style="display: flex; justify-content: space-between; font-size: 0.75rem; color: #6c757d;">
                <span>100</span>
                <span>50K</span>
                <span>100K</span>
                <span>200K</span>
              </div>
            </div>
            
            <!-- システムプロンプト -->
            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
              <label for="systemPrompt" style="font-weight: bold; color: #495057;">システムプロンプト:</label>
              <textarea id="systemPrompt" 
                style="padding: 0.5rem; border: 1px solid #ced4da; border-radius: 4px; resize: vertical; font-family: inherit; min-height: 80px;"
                placeholder="AIの動作を指定するプロンプトを入力してください...">あなたは親しみやすい日本語のアシスタントです。簡潔で自然な日本語で応答してください。英語は一切使わないでください</textarea>
            </div>
            
            <!-- ツール設定 -->
            <div style="margin: 0.5rem 0; display: flex; align-items: center; gap: 0.5rem;">
              <input type="checkbox" id="enableTools" style="transform: scale(1.2);">
              <label for="enableTools" style="font-weight: bold; color: #495057;">ツール使用を有効化 (JavaScript/Python実行)</label>
            </div>
            
            <button id="saveConfig" style="padding: 0.75rem 1rem; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">💾 設定保存</button>
            
            <div id="configStatus" style="padding: 0.5rem; font-size: 0.875rem; color: #6c757d;"></div>
          </div>
        </div>
      </div>

      <div style="flex: 1; display: flex; flex-direction: column; gap: 1rem;">
          <textarea id="results" rows="10" style="display:none;" placeholder="Output will appear here..." readonly style="flex: 1; padding: 0.75rem; font-size: 1rem; border: 1px solid #ced4da; border-radius: 8px; resize: none; background-color: #f8f9fa;"></textarea>
          <div id="conversation" style="text-align: left; width: 100%; max-height: 800px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 8px; background-color: #fafafa;"></div>
          
          <div style="display: flex; gap: 1rem; margin-top: 1rem;">
            <div id="speechStatus" style="padding: 0.75rem; font-size: 0.9rem; color: #6c757d; background-color: #f8f9fa; border-radius: 8px; flex: 1;"></div>
          </div>
      </div>

      <section flex="1" overflow="auto" id="sound-clips" style="display:none">
      </section>
  </div>


  <script src="sherpa-onnx-asr.js"></script>
  <script src="sherpa-onnx-vad.js"></script>
  <script src="app-vad-asr.js"></script>
  <script src="sherpa-onnx-wasm-main-vad-asr.js"></script>
  
  <!-- マークダウンパーサー -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  
  <script>
    // 音声合成機能の実装
    let speechSynth;
    let currentUtterance = null;
    let voices = [];
    
    // 音声合成の初期化
    function initSpeechSynthesis() {
      if ('speechSynthesis' in window) {
        speechSynth = window.speechSynthesis;
        
        // 音声一覧の取得（非同期）
        function loadVoices() {
          voices = speechSynth.getVoices();
          console.log('Available voices:', voices);
          
          // 日本語音声を探す
          const japaneseVoices = voices.filter(voice => 
            voice.lang.includes('ja') || voice.lang.includes('JP')
          );
          console.log('Japanese voices:', japaneseVoices);
        }
        
        // 音声一覧の読み込み完了を待つ
        if (voices.length === 0) {
          speechSynth.addEventListener('voiceschanged', loadVoices);
        } else {
          loadVoices();
        }
        
        return true;
      } else {
        console.error('Speech synthesis not supported');
        return false;
      }
    }
    
    // 設定の折りたたみを切り替える関数（グローバルスコープに配置）
    function toggleSettings() {
      const content = document.getElementById('settingsContent');
      const toggle = document.getElementById('settingsToggle');
      
      if (content.style.display === 'none') {
        content.style.display = 'block';
        toggle.textContent = '▼';
        localStorage.setItem('voiceui_settings_collapsed', 'false');
      } else {
        content.style.display = 'none';
        toggle.textContent = '▶';
        localStorage.setItem('voiceui_settings_collapsed', 'true');
      }
    }

    // トークン数表示を更新する関数（グローバルスコープに配置）
    function updateTokensDisplay(value) {
      const display = document.getElementById('maxTokensValue');
      if (!display) return;
      
      const numValue = parseInt(value);
      
      if (numValue >= 1000) {
        display.textContent = (numValue / 1000).toFixed(0) + 'K';
      } else {
        display.textContent = numValue;
      }
    }

    // 翻訳辞書
    const translations = {
      ja: {
        'main-title': 'VoiceLLM',
        'startBtn': '🎤 音声認識開始',
        'stopBtn': '⏹ 停止',
        'clearBtn': 'クリア',
        'speakBtn': '🔊 音声応答',
        'sendBtn': '📤 送信',
        'clearConversationBtn': '会話履歴クリア',
        'textInput-placeholder': 'メッセージを入力してEnterキーまたは送信ボタンを押してください...',
        'settings-title': '⚙️ LMStudio設定',
        'model-label': 'モデル:',
        'model-loading': 'モデルを読み込み中...',
        'tokens-label': '最大推奨トークン数:',
        'system-prompt-label': 'システムプロンプト:',
        'system-prompt-placeholder': 'AIの動作を指定するプロンプトを入力してください...',
        'system-prompt-default': 'あなたは親しみやすい日本語のアシスタントです。簡潔で自然な日本語で応答してください。英語は一切使わないでください',
        'tools-label': 'ツール使用を有効化 (JavaScript/Python実行)',
        'save-config': '💾 設定保存',
        'refresh-models': '🔄',
        'ai-thinking': 'AIに問い合わせ中...',
        'speech-init': '音声合成を初期化しています...',
        'speech-ready': '音声認識を開始してください',
        'speech-synth-init': '音声合成の初期化中...',
        'recognizing': '🎤 認識中...',
        'browser-speech-not-supported': 'このブラウザは音声認識をサポートしていません。テキスト入力をご利用ください。',
        'webassembly-fallback': 'WebAssembly音声認識が利用できません。ブラウザ音声認識を使用します。'
      },
      en: {
        'main-title': 'VoiceLLM',
        'startBtn': '🎤 Start Recognition',
        'stopBtn': '⏹ Stop',
        'clearBtn': 'Clear',
        'speakBtn': '🔊 Speak',
        'sendBtn': '📤 Send',
        'clearConversationBtn': 'Clear History',
        'textInput-placeholder': 'Enter message and press Enter or Send button...',
        'settings-title': '⚙️ LMStudio Settings',
        'model-label': 'Model:',
        'model-loading': 'Loading models...',
        'tokens-label': 'Max Recommended Tokens:',
        'system-prompt-label': 'System Prompt:',
        'system-prompt-placeholder': 'Enter system prompt to specify AI behavior...',
        'system-prompt-default': 'You are a friendly assistant. Please respond concisely and naturally.',
        'tools-label': 'Enable Tools (JavaScript/Python execution)',
        'save-config': '💾 Save Config',
        'refresh-models': '🔄',
        'ai-thinking': 'Querying AI...',
        'speech-init': 'Initializing speech synthesis...',
        'speech-ready': 'Please start voice recognition',
        'speech-synth-init': 'Initializing speech synthesis...',
        'recognizing': '🎤 Recognizing...',
        'browser-speech-not-supported': 'This browser does not support speech recognition. Please use text input.',
        'webassembly-fallback': 'WebAssembly speech recognition not available. Using browser speech recognition.'
      }
    };

    // 現在の言語（デフォルトは日本語）
    let currentLang = localStorage.getItem('voiceui_language') || 'ja';

    // UI言語を更新する関数
    function updateUILanguage() {
      const t = translations[currentLang];
      
      // テキスト要素を更新
      const elements = [
        'main-title', 'startBtn', 'stopBtn', 'clearBtn', 'speakBtn', 
        'sendBtn', 'clearConversationBtn', 'save-config'
      ];
      
      elements.forEach(id => {
        const element = document.getElementById(id);
        if (element && t[id]) {
          element.textContent = t[id];
        }
      });

      // プレースホルダーを更新
      const textInput = document.getElementById('textInput');
      if (textInput && t['textInput-placeholder']) {
        textInput.placeholder = t['textInput-placeholder'];
      }

      // 設定パネルのラベルを更新
      const settingsTitle = document.querySelector('#settingsHeader h3');
      if (settingsTitle && t['settings-title']) {
        settingsTitle.textContent = t['settings-title'];
      }

      // その他のラベル要素を更新
      const modelLabel = document.querySelector('label[for="modelSelect"]');
      if (modelLabel && t['model-label']) {
        modelLabel.textContent = t['model-label'];
      }

      const tokensLabel = document.querySelector('label[for="maxTokensSlider"]');
      if (tokensLabel && t['tokens-label']) {
        tokensLabel.textContent = t['tokens-label'];
      }

      const systemPromptLabel = document.querySelector('label[for="systemPrompt"]');
      if (systemPromptLabel && t['system-prompt-label']) {
        systemPromptLabel.textContent = t['system-prompt-label'];
      }

      const systemPrompt = document.getElementById('systemPrompt');
      if (systemPrompt) {
        if (t['system-prompt-placeholder']) {
          systemPrompt.placeholder = t['system-prompt-placeholder'];
        }
        // デフォルト値も更新（既存の値が空の場合）
        if (!systemPrompt.value.trim() || systemPrompt.value === translations.ja['system-prompt-default'] || systemPrompt.value === translations.en['system-prompt-default']) {
          systemPrompt.value = t['system-prompt-default'];
        }
      }

      const toolsLabel = document.querySelector('label[for="enableTools"]');
      if (toolsLabel && t['tools-label']) {
        toolsLabel.textContent = t['tools-label'];
      }

      // 言語トグルボタンを更新
      const langToggle = document.getElementById('langToggle');
      if (langToggle) {
        langToggle.textContent = currentLang === 'ja' ? '🌐 EN' : '🌐 JP';
      }

      // 音声認識の言語も更新
      if (typeof recognition !== 'undefined' && recognition) {
        recognition.lang = currentLang === 'ja' ? 'ja-JP' : 'en-US';
      }

      console.log(`UI language updated to: ${currentLang}`);
    }

    // 言語を切り替える関数
    function toggleLanguage() {
      currentLang = currentLang === 'ja' ? 'en' : 'ja';
      localStorage.setItem('voiceui_language', currentLang);
      updateUILanguage();
    }

    // ブラウザ音声認識のフォールバック関数
    function startBrowserSpeechRecognition() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        const t = translations[currentLang];
        alert(t['browser-speech-not-supported']);
        return;
      }

      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      const recognition = new SpeechRecognition();
      
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = currentLang === 'ja' ? 'ja-JP' : 'en-US';

      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const results = document.getElementById('results');

      recognition.onstart = function() {
        console.log('ブラウザ音声認識開始');
        startBtn.disabled = true;
        stopBtn.disabled = false;
        const t = translations[currentLang];
        startBtn.textContent = t['recognizing'];
      };

      recognition.onresult = function(event) {
        let finalTranscript = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
          if (event.results[i].isFinal) {
            finalTranscript += event.results[i][0].transcript;
          }
        }
        
        if (finalTranscript && results) {
          results.value = finalTranscript;
          console.log('音声認識結果:', finalTranscript);
        }
      };

      recognition.onerror = function(event) {
        console.error('音声認識エラー:', event.error);
        startBtn.disabled = false;
        stopBtn.disabled = true;
        const t = translations[currentLang];
        startBtn.textContent = t['startBtn'];
      };

      recognition.onend = function() {
        console.log('音声認識終了');
        startBtn.disabled = false;
        stopBtn.disabled = true;
        const t = translations[currentLang];
        startBtn.textContent = t['startBtn'];
      };

      // 停止ボタンの設定
      stopBtn.onclick = function() {
        recognition.stop();
      };

      recognition.start();
    }

    // 音声応答ボタンのイベントリスナー
    document.addEventListener('DOMContentLoaded', function() {
      const speakBtn = document.getElementById('speakBtn');
      const speechStatus = document.getElementById('speechStatus');
      const results = document.getElementById('results');
      
      // 音声合成の初期化
      const speechSupported = initSpeechSynthesis();
      
      if (!speechSupported) {
        speechStatus.textContent = 'お使いのブラウザは音声合成に対応していません';
        speakBtn.disabled = true;
        return;
      }
      
      // 音声認識の制御
      let isRecording = false;
      
      function pauseRecording() {
        const stopBtn = document.getElementById('stopBtn');
        if (!stopBtn.disabled) {
          console.log('Pausing recording for speech synthesis');
          stopBtn.click(); // 音声認識を停止
          isRecording = true; // 再開フラグを設定
        }
      }
      
      function resumeRecording() {
        const startBtn = document.getElementById('startBtn');
        if (isRecording && !startBtn.disabled) {
          console.log('Resuming recording after speech synthesis');
          setTimeout(() => {
            startBtn.click(); // 音声認識を再開
            isRecording = false;
          }, 500); // 少し遅延を入れる
        }
      }

      // 音声合成用にテキストをクリーンアップする関数
      function cleanTextForSpeech(text) {
        // マークダウンコードブロックを除去
        text = text.replace(/```[\s\S]*?```/g, '');
        
        // インラインコードを除去
        text = text.replace(/`[^`]*`/g, '');
        
        // コード関連の単語を除去
        text = text.replace(/JavaScript|Python|HTML|CSS|Node\.js|コード|プログラム|スクリプト|実行結果|Output:|Error:/gi, '');
        
        // 連続する空白を単一スペースに
        text = text.replace(/\s+/g, ' ').trim();
        
        return text;
      }
      
      // 英語部分を検出する関数
      function detectLanguageSegments(text) {
        // 音声合成用にテキストをクリーンアップ
        text = cleanTextForSpeech(text);
        console.log('Cleaned text for speech:', text);
        
        // 空になった場合は処理しない
        if (!text || text.trim().length === 0) {
          return [];
        }
        
        // 英語のフレーズを検出する正規表現（英単語+スペースを含む、クォートで囲まれた文字列も含む）
        const englishRegex = /("[^"]*")|([a-zA-Z]+(?:[''][a-zA-Z]+)*(?:\s+[a-zA-Z]+(?:[''][a-zA-Z]+)*)*)/g;
        const segments = [];
        let lastIndex = 0;
        let match;
        
        // 英語部分を検出
        while ((match = englishRegex.exec(text)) !== null) {
          // 英語の前の日本語部分
          if (match.index > lastIndex) {
            const japaneseText = text.substring(lastIndex, match.index).trim();
            if (japaneseText) {
              segments.push({ text: japaneseText, lang: 'ja-JP', type: 'japanese' });
            }
          }
          
          // マッチした内容を取得（クォート文字列またはアルファベット部分）
          const matchedText = match[1] || match[2]; // match[1]がクォート文字列、match[2]が通常の英語
          if (matchedText) {
            segments.push({ text: matchedText, lang: 'en-US', type: 'english' });
          }
          lastIndex = match.index + match[0].length;
        }
        
        // 最後の日本語部分
        if (lastIndex < text.length) {
          const remainingText = text.substring(lastIndex).trim();
          if (remainingText) {
            segments.push({ text: remainingText, lang: 'ja-JP', type: 'japanese' });
          }
        }
        
        // 英語が見つからない場合は全体を日本語として扱う
        if (segments.length === 0) {
          segments.push({ text: text.trim(), lang: 'ja-JP', type: 'japanese' });
        }
        
        return segments;
      }
      
      // 複数セグメントを順次再生する関数
      function speakSegments(segments, currentIndex = 0) {
        if (currentIndex >= segments.length) {
          console.log('All segments completed');
          speechStatus.textContent = 'AI応答完了';
          // 音声合成終了後に音声認識を再開
          resumeRecording();
          return;
        }
        
        const segment = segments[currentIndex];
        console.log(`Speaking segment ${currentIndex + 1}/${segments.length}: "${segment.text}" (${segment.lang})`);
        
        // 既存の音声を停止
        if (speechSynth.speaking || speechSynth.pending) {
          speechSynth.cancel();
        }
        
        const utterance = new SpeechSynthesisUtterance(segment.text);
        utterance.lang = segment.lang;
        
        // 言語に応じて音声を選択
        if (segment.type === 'english') {
          const englishVoice = voices.find(voice => 
            voice.lang.includes('en') || voice.lang.includes('US')
          );
          if (englishVoice) {
            utterance.voice = englishVoice;
            console.log('Using English voice:', englishVoice.name);
          }
        } else {
          const japaneseVoice = voices.find(voice => 
            voice.lang.includes('ja') || voice.lang.includes('JP')
          );
          if (japaneseVoice) {
            utterance.voice = japaneseVoice;
            console.log('Using Japanese voice:', japaneseVoice.name);
          }
        }
        
        utterance.rate = 0.9;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        utterance.onend = function() {
          // 次のセグメントを再生
          setTimeout(() => speakSegments(segments, currentIndex + 1), 100);
        };
        
        utterance.onerror = function(event) {
          console.error('Speech error in segment:', event);
          // エラーが発生しても次のセグメントに進む
          setTimeout(() => speakSegments(segments, currentIndex + 1), 100);
        };
        
        speechSynth.speak(utterance);
      }

      // 音声応答機能
      function speakText(text, isApiResponse = false) {
        console.log('speakText called with:', text, 'isApiResponse:', isApiResponse);
        
        if (!text || text.trim() === '') {
          speechStatus.textContent = '応答するテキストがありません';
          return;
        }
        
        let textToSpeak = '';
        
        if (isApiResponse) {
          // APIレスポンスの場合はそのまま使用
          textToSpeak = text.trim();
        } else {
          // 音声認識結果からテキスト部分のみを抽出
          const lines = text.split('\n');
          
          for (const line of lines) {
            if (line.includes('Result:')) {
              const resultPart = line.split('Result:')[1];
              if (resultPart) {
                textToSpeak += resultPart.trim() + ' ';
              }
            }
          }
        }
        
        if (!textToSpeak.trim()) {
          speechStatus.textContent = isApiResponse ? 'AIレスポンスが空です' : '音声認識結果がありません';
          return;
        }
        
        console.log('Text to speak:', textToSpeak);
        
        // 音声合成開始前に音声認識を停止
        pauseRecording();
        
        // 既存の音声を停止
        if (speechSynth.speaking || speechSynth.pending) {
          console.log('Cancelling previous speech');
          speechSynth.cancel();
        }
        
        // 言語セグメントに分割
        const segments = detectLanguageSegments(textToSpeak.trim());
        console.log('Language segments:', segments);
        
        speechStatus.textContent = isApiResponse ? 'AI応答中（録音停止）...' : '音声応答中（録音停止）...';
        
        // セグメントを順次再生
        speakSegments(segments);
      }
      
      // 音声認識結果が更新された時の処理
      let lastText = '';
      
      // テキストエリアの変更を監視
      const textAreaObserver = new MutationObserver(function(mutations) {
        const currentText = results.value;
        if (currentText !== lastText && currentText.trim() !== '') {
          console.log('Text area updated:', currentText);
          lastText = currentText;
          speechStatus.textContent = '音声応答準備完了';
        }
      });
      
      // テキストエリアのinputイベントも監視
      results.addEventListener('input', function() {
        const currentText = results.value;
        if (currentText !== lastText && currentText.trim() !== '') {
          console.log('Input event:', currentText);
          lastText = currentText;
          speechStatus.textContent = '音声応答準備完了';
        }
      });
      
      // マークダウンをHTMLに変換する関数
      function parseMarkdown(text) {
        if (typeof marked !== 'undefined') {
          // markedライブラリが利用可能な場合
          return marked.parse(text);
        } else {
          // フォールバック: 簡単なマークダウン処理
          return text
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/`(.*?)`/g, '<code>$1</code>')
            .replace(/\n/g, '<br/>');
        }
      }

      // Python API サーバー呼び出し機能
      async function callPythonAPI(userInput) {
        var conversation = document.getElementById('conversation');
        try {
          speechStatus.textContent = 'AIに問い合わせ中...';
          conversation.innerHTML += "<div style='margin: 10px 0; padding: 10px; background: #e3f2fd; border-radius: 5px; text-align: left;'><B>USER:</B> <span style='color: #1976d2;'>" + userInput + "</span></div>";
          
          const enableTools = document.getElementById('enableTools').checked;
          
          const systemPrompt = document.getElementById('systemPrompt').value;
          
          const response = await fetch('/api/chat', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              message: userInput,
              enable_tools: enableTools,
              system_prompt: systemPrompt
            })
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          
          if (data.status === 'success') {
            const aiResponse = data.response;
            console.log('Python API response:', aiResponse);
            
            // マークダウンをHTMLに変換
            const htmlResponse = parseMarkdown(aiResponse);
            
            // APIレスポンスを表示
            conversation.innerHTML += "<div style='margin: 10px 0; padding: 10px; background: #f1f8e9; border-radius: 5px; text-align: left;'><B>AI:</B> <div style='color: #388e3c; margin-top: 5px; text-align: left;'>" + htmlResponse + "</div></div>";
            
            // 音声合成では元のテキストを使用（HTMLタグなし）
            speakText(aiResponse, true);
            
            // 会話履歴の最下部にスクロール
            conversation.scrollTop = conversation.scrollHeight;
          } else {
            throw new Error(data.error || 'Unknown error');
          }
          
        } catch (error) {
          console.error('Python API error:', error);
          speechStatus.textContent = 'API接続エラー: ' + error.message;
          
          // エラー時は元のテキストをそのまま読み上げ
          speakText(`${userInput}について、理解しました。`, true);
        }
      }

      // PropertyObserver（テキストエリアの値の変更を検知）
      let lastValue = '';
      setInterval(function() {
        if (results.value !== lastValue) {
          lastValue = results.value;
          console.log("音声認識結果:", lastValue)
          
          // 音声認識結果からテキストを抽出
          const lines = lastValue.split('\n');
          let recognizedText = '';
          for (const line of lines) {
            if (line.includes('Result:')) {
              const resultPart = line.split('Result:')[1];
              if (resultPart) {
                recognizedText += resultPart.trim() + ' ';
              }
            }
          }
          
          if (recognizedText.trim()) {
            // Python APIサーバーを呼び出し
            callPythonAPI(recognizedText.trim());
          }
          
          results.value="";
          const clearBtn = document.getElementById('clearBtn');
          clearBtn.click();

          if (lastValue.trim() !== '') {
            speechStatus.textContent = '音声応答準備完了';
          }
        }
      }, 500);
      
      // モデル一覧を取得する関数
      async function loadModels() {
        const modelSelect = document.getElementById('modelSelect');
        const configStatus = document.getElementById('configStatus');
        
        try {
          configStatus.textContent = 'モデル一覧を取得中...';
          
          const response = await fetch('/api/models');
          const data = await response.json();
          
          console.log('Received models data:', data);
          console.log('First model details:', data.models[0]);
          
          if (data.status === 'success') {
            modelSelect.innerHTML = '';
            
            if (data.models.length === 0) {
              modelSelect.innerHTML = '<option value="">モデルが見つかりません</option>';
              configStatus.textContent = 'LMStudioでモデルをロードしてください';
            } else {
              data.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                const contextLength = model.max_context_length || 4096;
                option.textContent = `${model.id} (context: ${contextLength.toLocaleString()})`;
                option.setAttribute('data-max-context', contextLength);
                modelSelect.appendChild(option);
                console.log(`Added model: ${model.id}, context: ${contextLength}`);
              });
              configStatus.textContent = `${data.models.length}個のモデルが利用可能`;
            }
          } else {
            throw new Error(data.error);
          }
        } catch (error) {
          console.error('Failed to load models:', error);
          modelSelect.innerHTML = '<option value="">エラー: モデル取得失敗</option>';
          configStatus.textContent = 'LMStudioとの接続を確認してください';
        }
      }
      
      // 現在の設定を取得する関数
      async function loadConfig() {
        try {
          const response = await fetch('/api/config');
          const data = await response.json();
          
          if (data.status === 'success') {
            const modelSelect = document.getElementById('modelSelect');
            const maxTokensSlider = document.getElementById('maxTokensSlider');
            
            if (modelSelect) {
              modelSelect.value = data.model_id;
            }
            if (maxTokensSlider) {
              maxTokensSlider.value = data.max_tokens;
              updateTokensDisplay(data.max_tokens);
            }
          }
        } catch (error) {
          console.error('Failed to load config:', error);
        }
        
        // ローカルストレージから設定を読み込み
        loadLocalSettings();
      }
      
      // ローカルストレージから設定を読み込む関数
      function loadLocalSettings() {
        try {
          // 設定パネルの表示状態を復元（デフォルトは折りたたみ）
          const collapsed = localStorage.getItem('voiceui_settings_collapsed');
          if (collapsed === 'false') {
            document.getElementById('settingsContent').style.display = 'block';
            document.getElementById('settingsToggle').textContent = '▼';
          } else {
            // デフォルトは折りたたみ
            document.getElementById('settingsContent').style.display = 'none';
            document.getElementById('settingsToggle').textContent = '▶';
          }
          
          const enableTools = localStorage.getItem('voiceui_enable_tools');
          if (enableTools !== null) {
            document.getElementById('enableTools').checked = enableTools === 'true';
          }
          
          const modelId = localStorage.getItem('voiceui_model_id');
          if (modelId && document.getElementById('modelSelect')) {
            // モデルオプションが読み込まれた後に設定
            setTimeout(() => {
              const selectElement = document.getElementById('modelSelect');
              if (selectElement && Array.from(selectElement.options).some(option => option.value === modelId)) {
                selectElement.value = modelId;
                // モデル変更時にmax_tokensを自動更新
                updateMaxTokensFromModel();
              }
            }, 500);
          }
          
          const maxTokens = localStorage.getItem('voiceui_max_tokens');
          if (maxTokens) {
            const slider = document.getElementById('maxTokensSlider');
            slider.value = maxTokens;
            updateTokensDisplay(maxTokens);
          }
          
          const systemPrompt = localStorage.getItem('voiceui_system_prompt');
          if (systemPrompt) {
            document.getElementById('systemPrompt').value = systemPrompt;
          }
          
          console.log('Loaded settings from localStorage');
        } catch (error) {
          console.error('Failed to load settings from localStorage:', error);
        }
      }
      
      // ローカルストレージに設定を保存する関数
      function saveLocalSettings() {
        try {
          const enableTools = document.getElementById('enableTools').checked;
          const modelId = document.getElementById('modelSelect').value;
          const maxTokens = document.getElementById('maxTokensSlider').value;
          const systemPrompt = document.getElementById('systemPrompt').value;
          
          localStorage.setItem('voiceui_enable_tools', enableTools);
          localStorage.setItem('voiceui_model_id', modelId);
          localStorage.setItem('voiceui_max_tokens', maxTokens);
          localStorage.setItem('voiceui_system_prompt', systemPrompt);
          
          console.log('Saved settings to localStorage');
        } catch (error) {
          console.error('Failed to save settings to localStorage:', error);
        }
      }
      
      // 設定を保存する関数
      async function saveConfig() {
        const modelSelect = document.getElementById('modelSelect');
        const maxTokensSlider = document.getElementById('maxTokensSlider');
        const enableTools = document.getElementById('enableTools');
        const configStatus = document.getElementById('configStatus');
        
        try {
          configStatus.textContent = '設定を保存中...';
          
          const response = await fetch('/api/config', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              model_id: modelSelect.value,
              max_tokens: parseInt(maxTokensSlider.value)
            })
          });
          
          const data = await response.json();
          
          if (data.status === 'success') {
            // ローカルストレージにも保存
            saveLocalSettings();
            
            const toolsStatus = enableTools.checked ? 'ツール有効' : 'ツール無効';
            configStatus.textContent = `設定保存完了 - モデル: ${data.model_id}, 推奨トークン数: ${data.max_tokens}, ${toolsStatus}`;
            configStatus.style.color = '#28a745';
          } else {
            throw new Error(data.error);
          }
        } catch (error) {
          console.error('Failed to save config:', error);
          configStatus.textContent = '設定の保存に失敗しました';
        }
      }
      
      // 会話履歴をクリアする関数
      async function clearConversation() {
        const configStatus = document.getElementById('configStatus');
        const conversation = document.getElementById('conversation');
        
        try {
          configStatus.textContent = '会話履歴をクリア中...';
          
          const response = await fetch('/api/conversation', {
            method: 'DELETE'
          });
          
          const data = await response.json();
          
          if (data.status === 'success') {
            conversation.innerHTML = '';
            configStatus.textContent = '会話履歴をクリアしました';
          } else {
            throw new Error(data.error);
          }
        } catch (error) {
          console.error('Failed to clear conversation:', error);
          configStatus.textContent = '会話履歴のクリアに失敗しました';
        }
      }
      
      // スライダーのラベルを更新する関数
      function updateSliderLabels(maxValue) {
        const labels = document.getElementById('sliderLabels');
        const quarter = Math.floor(maxValue / 4);
        const half = Math.floor(maxValue / 2);
        const threeQuarter = Math.floor(maxValue * 3 / 4);
        
        function formatValue(value) {
          if (value >= 1000) {
            return Math.floor(value / 1000) + 'K';
          }
          return value.toString();
        }
        
        labels.innerHTML = `
          <span>100</span>
          <span>${formatValue(quarter)}</span>
          <span>${formatValue(half)}</span>
          <span>${formatValue(threeQuarter)}</span>
          <span>${formatValue(maxValue)}</span>
        `;
      }
      
      // モデル選択時にmax_tokensを自動設定
      function updateMaxTokensFromModel() {
        const modelSelect = document.getElementById('modelSelect');
        const maxTokensSlider = document.getElementById('maxTokensSlider');
        const configStatus = document.getElementById('configStatus');
        
        const selectedOption = modelSelect.options[modelSelect.selectedIndex];
        if (selectedOption && selectedOption.getAttribute('data-max-context')) {
          const maxContext = parseInt(selectedOption.getAttribute('data-max-context'));
          
          // 推奨トークン数をmax_context_lengthの75%に設定（余裕を持たせる）
          const recommendedMaxTokens = Math.floor(maxContext * 0.75);
          
          // スライダーの最大値をモデルのコンテキスト長に設定
          const sliderMax = Math.min(maxContext, 500000); // 最大500Kまで
          maxTokensSlider.max = sliderMax;
          maxTokensSlider.value = recommendedMaxTokens;
          updateTokensDisplay(recommendedMaxTokens);
          updateSliderLabels(sliderMax);
          
          configStatus.textContent = `モデルのコンテキスト長: ${maxContext.toLocaleString()}, 推奨トークン数: ${recommendedMaxTokens.toLocaleString()}`;
        } else {
          // デフォルト設定（モデル情報がない場合）
          maxTokensSlider.max = 32768;
          updateSliderLabels(32768);
        }
      }
      
      // テキスト送信機能
      async function sendTextMessage() {
        const textInput = document.getElementById('textInput');
        const message = textInput.value.trim();
        
        if (!message) {
          return;
        }
        
        // 入力フィールドをクリア
        textInput.value = '';
        
        // 音声応答を呼び出し
        await callPythonAPI(message);
      }
      
      // イベントリスナーの設定
      document.getElementById('refreshModels').addEventListener('click', loadModels);
      document.getElementById('saveConfig').addEventListener('click', saveConfig);
      document.getElementById('clearConversationBtn').addEventListener('click', clearConversation);
      document.getElementById('modelSelect').addEventListener('change', updateMaxTokensFromModel);
      
      // テキスト入力のイベントリスナー
      document.getElementById('sendBtn').addEventListener('click', sendTextMessage);
      document.getElementById('textInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          sendTextMessage();
        }
      });
      
      // 言語切り替えボタンのイベントリスナー
      document.getElementById('langToggle').addEventListener('click', toggleLanguage);
      
      // 初期状態設定
      speechStatus.textContent = '音声合成を初期化しています...';
      
      // 初期化完了後の処理
      setTimeout(async () => {
        // Loading状態を手動で解除
        const statusElement = document.getElementById('status');
        if (statusElement) {
          statusElement.style.display = 'none';
        }
        document.querySelectorAll('.tab-content').forEach((tabContentElement) => {
          tabContentElement.classList.remove('loading');
        });
        
        // 音声認識ボタンを手動で有効化
        const startBtn = document.getElementById('startBtn');
        if (startBtn) {
          startBtn.disabled = false;
          
          // app-vad-asr.jsのイベントハンドラーが設定されていない場合のフォールバック
          // 少し遅延してからチェック
          setTimeout(() => {
            if (startBtn.onclick === null) {
              console.log('WebAssembly音声認識が利用できません。ブラウザ音声認識を使用します。');
              startBtn.onclick = function() {
                startBrowserSpeechRecognition();
              };
            }
          }, 2000);
        }
        
        if (speechSynth && speechSynth.getVoices().length > 0) {
          speechStatus.textContent = '音声認識を開始してください';
        } else {
          speechStatus.textContent = '音声合成の初期化中...';
        }
        
        // 言語設定を適用
        updateUILanguage();
        
        // モデル一覧と現在の設定を読み込み
        await loadModels();
        await loadConfig();
        
        // 初期モデル選択時にmax_tokensを自動設定
        updateMaxTokensFromModel();
      }, 1000);
    });
  </script>
</body>
